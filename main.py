#%%
from __future__ import annotations

import copy
import json
from collections.abc import Iterable
from pathlib import Path

import freetype
import numpy as np
from shapely.geometry import Polygon

from parser import Line, build_rectangles_for_glyph, lines_to_world


def rectangles_to_line_segments(rectangles: Iterable[Polygon]) -> np.ndarray:
    """Convert rectangles into their medial axis line segments.

    Parameters
    ----------
    rectangles : iterable of Polygon
        Rectangles whose long axes should be extracted.

    Returns
    -------
    ndarray
        Array of shape ``(N, 2, 2)`` with start/end coordinates for each rectangle segment.
    """
    rectangle_vertices = [np.asarray(polygon.exterior.coords, dtype=float)[:4] for polygon in rectangles]
    if not rectangle_vertices:
        return np.empty((0, 2, 2), dtype=float)

    vertices = np.stack(rectangle_vertices, axis=0)
    starts = (vertices[:, 0, :] + vertices[:, 3, :]) / 2.0
    ends = (vertices[:, 1, :] + vertices[:, 2, :]) / 2.0
    segments = np.stack([starts, ends], axis=1)
    segments[:, :, 0] *= -1  # flip X for drawing conventions
    return segments


def write_blueprint(lines: list[Line], base_blueprint: Path, output_path: Path) -> None:
    """Write a new blueprint JSON by cloning objects from a base template.

    Parameters
    ----------
    lines : list of Line
        Blueprint line descriptors generated by :func:`sat_sav_parse.lines_to_world`.
    base_blueprint : Path
        Path to the base blueprint file used as a template.
    output_path : Path
        Path where the generated blueprint should be written.
    """
    with base_blueprint.open(encoding="utf-8") as handle:
        blueprint = json.load(handle)

    sample_object = copy.deepcopy(blueprint["objects"][1])
    blueprint["objects"] = []

    for line in lines:
        instance = copy.deepcopy(sample_object)
        instance["properties"]["mLength"]["value"] = line.length * 10
        instance["transform"]["rotation"] = line.rotation
        jitter = np.random.uniform(-0.1, 0.1)
        instance["transform"]["translation"] = {
            "x": line.translation["x"] * 10,
            "y": line.translation["y"] * 10,
            "z": line.translation["z"] * 10 + jitter,
        }
        blueprint["objects"].append(instance)

    blueprint["name"] = "New Blueprint 2"

    with output_path.open("w", encoding="utf-8") as handle:
        json.dump(blueprint, handle, indent=2)


def main() -> None:
    """Generate rectangles for a glyph and export blueprint data.

    Returns
    -------
    None
        This function executes for its side effects.
    """
    font_path = Path("fonts/LavishlyYours-Regular.ttf")
    face = freetype.Face(str(font_path))
    scale = 10
    geometry, rectangles = build_rectangles_for_glyph(
        face,
        char="E",
        pixel_height=20 * scale,
        thickness=0.75 * scale,
        overlap=0.0,
        min_segment_length=0.5 * scale,
        rdp_epsilon=0.0,
        fill_orientation="horizontal",
        safety_inset=0.0,
    )
    print(f"{len(rectangles)} rectangles placed.")

    if geometry.is_empty:
        return

    line_segments = rectangles_to_line_segments(rectangles)
    base_blueprint = Path("base_blueprint/New Blueprint.json")
    output_path = Path("base_blueprint/New Blueprint 2.json")
    write_blueprint(lines_to_world(line_segments), base_blueprint, output_path)


if __name__ == "__main__":
    main()
